(function() {
    var Globals = {};


    $(document).on("turbolinks:load", function() {
        if ($("#graph_general_statistics").length) {
            $.ajax({
                type: "GET",
                contentType: "application/json; charset=utf-8",
                url: "appstats/data_general_statistics",
                dataType: "json",
                success: function(generalStatisticsDataSet) {
                    var dataMain = _.cloneDeep(generalStatisticsDataSet);
                    var dataMini = _.cloneDeep(generalStatisticsDataSet);

                    draw_graph_general_statistics(dataMain, false, 0, false);

                    draw_graph_mini(dataMini[0], "#mini0");
                    document.getElementById("mini0").addEventListener("click", function() { load_new_data(0); })
                    draw_graph_mini(dataMini[1], "#mini1");
                    document.getElementById("mini1").addEventListener("click", function() { load_new_data(1); })
                    draw_graph_mini(dataMini[2], "#mini2");
                    document.getElementById("mini2").addEventListener("click", function() { load_new_data(2); })
                    draw_graph_mini(dataMini[3], "#mini3");
                    document.getElementById("mini3").addEventListener("click", function() { load_new_data(3); })
                },
                error: function(result) {
                    error();
                }
            });
            // Redraw graph if the date range is changed
            document.getElementById("dateButton").addEventListener("click", function() { 
                var from = $( "#from" ).datepicker( "getDate" );
                var to = $( "#to" ).datepicker( "getDate" );
                $.ajax({
                    type: "GET",
                    contentType: "application/json; charset=utf-8",
                    url: "appstats/data_general_statistics",
                    dataType: "json",
                    data: {
                        "start_date": from,
                        "end_date": to
                    },
                    success: function(generalStatisticsDataSet) {
                        var dataMain = _.cloneDeep(generalStatisticsDataSet);
                        var dataMini = _.cloneDeep(generalStatisticsDataSet);
                        // $(".focus").remove();
                        // $(".context").remove();
                        // $(".zoom").remove();
                        d3.select("#graph_general_statistics").selectAll(".focus, .context, .zoom")
                            .transition().duration(500)
                            .style("opacity", .000001)
                            .remove();

                        draw_graph_general_statistics(dataMain, false, 0, true);


                        draw_graph_mini(dataMini[0], "#mini0");
                        document.getElementById("mini0").addEventListener("click", function() { load_new_data(0); })
                        draw_graph_mini(dataMini[1], "#mini1");
                        document.getElementById("mini1").addEventListener("click", function() { load_new_data(1); })
                        draw_graph_mini(dataMini[2], "#mini2");
                        document.getElementById("mini2").addEventListener("click", function() { load_new_data(2); })
                        draw_graph_mini(dataMini[3], "#mini3");
                        document.getElementById("mini3").addEventListener("click", function() { load_new_data(3); })
                    },
                    error: function(result) {
                        error();
                    }
                });
            });
        }
    });

    function error() {
        console.log("Error retrieving data");
    }

    function draw_graph_general_statistics(dataShared, transitioning, index, dateUpdated) {
        var transitioning = transitioning;
        var svg = d3.select("#graph_general_statistics"),
            dataInt = dataShared[index],
            margin = {
                top: 20,
                right: 20,
                bottom: 110,
                left: 40
            },
            margin2 = {
                top: 430,
                right: 20,
                bottom: 30,
                left: 40
            },
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom,
            height2 = +svg.attr("height") - margin2.top - margin2.bottom,
            titles = ["Clicks", "Serves", "Sessions", "Searches"],
            title = titles[index];
        

        // Parse dates into proper format
        var parseDate = d3.timeParse("%Y-%m-%d");

        dataInt.forEach(function(d) {
            d.date = parseDate(d.date);
        });

        // Make scales
        var x = d3.scaleTime().range([0, width]),
            x2 = d3.scaleTime().range([0, width]),
            y = d3.scaleLinear().range([height, 0]),
            y2 = d3.scaleLinear().range([height2, 0]);

        // Make brush and zoom
        var brush = d3.brushX()
            .extent([
                [0, 0],
                [width, height2]
            ])
            .on("brush end", brushed);

        var zoom = d3.zoom()
            .scaleExtent([1, 1000])
            .translateExtent([
                [0, 0],
                [width, height]
            ])
            .extent([
                [0, 0],
                [width, height]
            ])
            .on("zoom", zoomed);

        // Set domains
        if (_.isEqual(undefined, Globals.Domain) || dateUpdated) {
            x.domain(d3.extent(dataInt, function(d) {
                return d.date;
            }));
        } else {
            x.domain(Globals.Domain);
        }
        y.domain([0, d3.max(dataInt, function(d) {
            return d.count;
        })]);
        x2.domain(d3.extent(dataInt, function(d) {
            return d.date;
        }));
        y2.domain(y.domain());
        //Globals.Domain = x.domain();

        // Make axes
        var xAxis = d3.axisBottom(x),
            xAxis2 = d3.axisBottom(x2),
            yAxis = d3.axisLeft(y);

        // Make areas
        var area = d3.area()
            .curve(d3.curveMonotoneX)
            .x(function(d) {
                return x(d.date);
            })
            .y0(height)
            .y1(function(d) {
                return y(d.count);
            });

        var area2 = d3.area()
            .curve(d3.curveMonotoneX)
            .x(function(d) {
                return x2(d.date);
            })
            .y0(height2)
            .y1(function(d) {
                return y2(d.count);
            });

        // Make focus
        var focusSelection = svg.selectAll(".focus").data([dataInt]);

        focusSelection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        focusSelection.enter().append("g")
            .attr("class", "focus")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var focus = svg.select(".focus");

        // Make context
        var contextSelection = svg.selectAll(".context").data([dataInt]);

        contextSelection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        contextSelection.enter().append("g")
            .attr("class", "context")
            .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

        var context = svg.select(".context");

        // Before updating domains, move brush to domain it was previously set to
        if (dateUpdated) {
            context.select(".brush").call(brush.move, [x2(Globals.Domain[0]),x2(Globals.Domain[1])]);
        }

        // Make clip path
        var clipSelection = svg.selectAll("defs").data([dataInt]);

        clipSelection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        clipSelection.enter().append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", width)
            .attr("height", height);

        // Make focus x axis
        var xAxisSelection = focus.selectAll(".xAxis").data([dataInt]);

        xAxisSelection.transition().duration(750)
            .call(xAxis);
        xAxisSelection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        xAxisSelection.enter().append("g")
            .style("opacity", .000001)
            .attr("class", "xAxis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis)
            .transition().delay(750).duration(500)
            .style("opacity", 1);

        // Make focus y axis
        var yAxisSelection = focus.selectAll(".yAxis").data([dataInt]);

        yAxisSelection.transition().duration(750)
            .call(yAxis);
        yAxisSelection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        yAxisSelection.enter().append("g")
            .style("opacity", .000001)
            .attr("class", "yAxis")
            .attr("transform", "translate(0,0)")
            .call(yAxis)
            .transition().delay(750).duration(500)
            .style("opacity", 1);

        // Make chart title
        var titleSelection = focus.selectAll(".chartTitle").data([dataInt]);

        titleSelection.transition().duration(325)
            .style("opacity", .00001)
            .transition()
            .text(title)
            .transition().duration(325)
            .style("opacity", 1);
        titleSelection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        titleSelection.enter().append("text")
            .style("opacity", .000001)
            .text(title)
            .attr("class", "chartTitle")
            .attr("transform", "translate(" + (width / 2) + "," + 30 + ")")
            .transition().delay(750).duration(500)
            .style("opacity", 1);

        // Make focus path
        var focusPathSelection = focus.selectAll(".area").data([dataInt]);

        focusPathSelection.datum(dataInt).transition().duration(750)
            .attr("d", area);
        focusPathSelection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        focusPathSelection.enter().append("path")
            .style("opacity", .000001)
            .datum(dataInt)
            .attr("class", "area")
            .transition().delay(750).duration(500)
            .style("opacity", 1);;

        // Make context x axis
        var xAxis2Selection = context.selectAll(".xAxis").data([dataInt]);

        xAxis2Selection.transition().duration(500)
            .call(xAxis2);
        xAxis2Selection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        xAxis2Selection.enter().append("g")
            .style("opacity", .000001)
            .attr("class", "xAxis")
            .attr("transform", "translate(0," + height2 + ")")
            .call(xAxis2)
            .transition().delay(750).duration(500)
            .style("opacity", 1);

        // Make context path
        var contextPathSelection = context.selectAll(".area").data([dataInt]);

        contextPathSelection.datum(dataInt).transition().duration(750)
            .attr("d", area2);
        contextPathSelection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        contextPathSelection.enter().append("path")
            .style("opacity", .000001)
            .datum(dataInt)
            .attr("class", "area")
            .attr("d", area2)
            .transition().delay(750).duration(500)
            .style("opacity", 1);

        // Make brush container
        var brushSelection = context.selectAll(".brush").data([dataInt]);

        brushSelection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        brushSelection.enter().append("g")
            .attr("class", "brush")
            .call(brush)
            .call(brush.move, x.range())
        .merge(brushSelection)
            .call(brush);

        // Have to prevent zoom or brush temporarily for transitions to execute
        if (transitioning) {
            setTimeout(function() {
                transitioning = false;
            }, 50);
        } // If not on transition, don't fade in brush
        else {
            svg.selectAll(".brush")
                .style("opacity", .000001)
                .transition().delay(750).duration(500)
                .style("opacity", 1);
        }

        // Make zoom container
        var zoomSelection = svg.selectAll(".zoom").data([dataInt]);

        zoomSelection.exit().transition().duration(500)
            .style("opacity", .000001)
            .remove();
        zoomSelection.enter().append("rect")
            .attr("class", "zoom")
            .attr("width", width)
            .attr("height", height)
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .merge(zoomSelection)
            .call(zoom);


        function brushed() {
            if (!transitioning) {
                if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return;
                var s = d3.event.selection || x2.range();
                x.domain(s.map(x2.invert, x2));
                Globals.Domain = x.domain();
                focus.select(".area").attr("d", area);
                focus.select(".xAxis").call(xAxis);
                svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
                    .scale(width / (s[1] - s[0]))
                    .translate(-s[0], 0));
            }
        }

        function zoomed() {
            if (!transitioning) {
                if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return;
                var t = d3.event.transform;
                x.domain(t.rescaleX(x2).domain());
                Globals.Domain = x.domain();
                focus.select(".area").attr("d", area);
                focus.select(".xAxis").call(xAxis);
                context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
            }
        }

        function type(d) {
            d.date = parseDate(d.date);
            d.count = +d.count;
            return d;
        }
    }

    function load_new_data(index) {
        $.ajax({
            type: "GET",
            contentType: "application/json; charset=utf-8",
            url: "appstats/data_general_statistics",
            dataType: "json",
            success: function(updateDataSet) {
                var updateData = _.cloneDeep(updateDataSet);
                draw_graph_general_statistics(updateData, true, index, false);
            },
            error: function(result) {
                error();
            }
        });
    }

    function draw_graph_mini(dataShared, id) {
        var svg = d3.select(id),
            dataInt = dataShared,
            margin = {
                top: 5,
                right: 5,
                bottom: 5,
                left: 5
            }
        width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom,
            title = "";
        if (id == "#mini0") {
            title = "Clicks";
        }
        if (id == "#mini1") {
            title = "Serves";
        }
        if (id == "#mini2") {
            title = "Sessions";
        }
        if (id == "#mini3") {
            title = "Searches";
        }

        var parseDate = d3.timeParse("%Y-%m-%d");

        dataInt.forEach(function(d) {
            d.date = parseDate(d.date);
        });

        var x = d3.scaleTime().range([0, width]),
            y = d3.scaleLinear().range([height, 0]);

        x.domain(d3.extent(dataInt, function(d) {
            return d.date;
        }));
        y.domain([0, d3.max(dataInt, function(d) {
            return d.count;
        })]);

        var xAxis = d3.axisBottom(x),
            yAxis = d3.axisLeft(y);

        xAxis.tickSizeOuter(0);
        yAxis.tickSizeOuter(0);

        var area = d3.area()
            .curve(d3.curveMonotoneX)
            .x(function(d) {
                return x(d.date);
            })
            .y0(height)
            .y1(function(d) {
                return y(d.count);
            });

        svg.append("defs").append("clipPath")
            .attr("id", "clipMini")
            .append("rect")
            .attr("width", width)
            .attr("height", height);

        var focus = svg.append("g")
            .attr("class", "focus")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        focus.append("path")
            .datum(dataInt)
            .attr("class", "areaMini")
            .attr("d", area);

        focus.append("text")
            .text(title)
            .attr("class", "chartTitle")
            .attr("transform", "translate(" + (width / 2) + "," + (height / 2) + ")");

        focus.append("g")
            .attr("class", "xAxis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis.ticks(0));

        focus.append("g")
            .attr("class", "yAxis")
            .call(yAxis.ticks(0));
    }

})();